una classe è un metodo di astrazione per gli oggetti reali, cioè l'idea che definisce oggetti reali. Il suo blueprint.
il tipo di un oggetto è definito dalla sua classe, se ho la classe automobile, l'oggetto sarà di tipo automobile
l'attributo di un oggetto è dato dalle variabili presenti nella classe, a cui noi assegniamo un valore

una classe può contenere al suo interno altre classi

un attributo è una caratteristica o proprietà (una variabile) che descrive l'oggetto

il metodo è una funziona associata alla classe, che descrive il comportamento che un oggetto presente nella classe possiede

l'istanza(oggetto) è la realizzazione concreta della classe

ci sono due metodi speciali nelle classi: __init__ il metodo costruttore, cioè le fondamenta della classe su cui creiamo gli oggetti 
a cui diamo attributi e valori iniziali. Accetta sempre almeno un parametro: il self
il secondo è __str__ che fornisce la rappresentazione in stringa di un oggetto, importante per la lettura 

un metodo che è dentro la classe che non utilizza i dati dell'oggetto e utilizza i dati della classe. Legato alla classe ma non lavora
su oggetto né alla classe

metodo di istanza è nella classe ma lavora sull'oggetto. 

funzioni: cosa sono
sono blocchi di codici che gestiscono dei valori in modo separato e che noi richiamiamo ogniqualvolta ne abbiamo bisogno
una funzione si definisce da 3 parametri fondamentali, di cui uno è def, nome e parametri
quando inserisci un valore reale, diventa argomento
esistono due tipi funzioni, una di ritorno e una non.
quella di ritorno restituisce la funzione quando la chiamiamo con il comando "return"
ci sono diversi tipi di parametri, quelli posizionali, le keyword e quelli di default

I generatori sono una classe di funzioni che permettonon di iterare su una serie di valori ma restituiscono tali valori
solo una alla volta e utilizzano come keyword yeald
yieald restituisce un valore

decoratori sono delle funzioni create per impacchettarne altre e estendere le applicazioni delle funzioni senza dover modificare
il codice originario della funzione. Questo permette di essere più versatili ed evitare di apporre modifiche innopportune

MODULI

qual è l'obiettivo di questo codice? possiamo usare quella logica isolandola
sostanzialmente i moduli servono ad isolare pezzi che fanno qualcosa di specifico che posso richiamare quando voglio
o testare se funziona

in python l'obiettivo non è dividere il più possibile ma suddividere nelle parti necessarie per avere un minimo di controllo e gestione
quando sappiamo come gestire il file è fatta, usiamo cosi il codice.
non c'è nessuna necessità di andare ad avere 10000 logiche per fare la stessa cosa

tramite il nome del modulo posso richiamare tutte le sue funzioni

--------------------------------------------------------------------------------------------------------

LE TRE REGOLE DELL'OOP

3+1 CONCETTI FONDAMENTALI
Ereditarietà, Incapsulamento, Polimorfismo (di pari importanza)
se manca una di loro le altre crollano
+1 FONDATIVA (BASILARE)
se rimuovo l'astrazione le altre 3 regole non possono più funzionare CONTEMPORANEAMENTE 
l'Astrazione è la regola BASE di tutti i linguaggi di programmazione moderni OOP

L'ereditarietà è quella più manipolabile dal programmatore 75-25
incapsulamento 50-50 (implicito e 50 aggiungere o no)
polimorfismo (75-25, esagerando, in mano all'utente)

le 3 regole collaborano SEMPRE tra di loro

Incapsulamento
la capacità di difendere gli elementi interni (di classe, funzione, variabili etc.) a livello di SICUREZZA DEL CODICE
lavoriamo con le giuste norme alla base per far funzionare tutto il resto

Ereditarietà
La capacità di una classe di poter ereditare da altre classi (chiamata padre) che può ereditare metodi e attributi
è una caratteristica UNICA di python e si chiama multiereditarietà. Inoltre una classe può avere infiniti padri (cioè
può avere infiniti attributi o moduli ereditari) e vale IL VICEVERSA (infiniti figli)
uno dei motivi basilari per cui python è molto utile per il machine learning/IA

l'ereditarietà la vediamo in 3 cose: metodo attivo/passivo e una capacità. Una classe padre si chiama superclasse o padre. 
Figlio si dice sottoclasse o figlio
ogni classe figlio può ereditare attributi e metodi.
3 modi per utilizzare l'er. attivamente/pratici: super permette di richiamare metodi o costruttori esattamente come è scritta
nella classe padre (con super.x la chiamiamo esattamente il metodo del padre)
LA SOVRASCRITTURA: sovrascriviamo i metodi del padre (padre "saluta") noi lo riscriviamo e invece di def saluta="ciao" lo riscriviamo
come ="hello". Riscrivamo il metodo
L'EREDITARIETà MULTIPLA non è attiva nè passiva ma tipica di Python. Ogni padre può avere inf figli e ogni figli può avere inf padri



Polimorfismo
il polimorfismo è la capacità di cambiare forma e/o comportamento ad un elemento senza cambiarne il tipo
Ingegneristicamente


INCAPSULAMENTO:

2 Modi per usare l'incapsulamento:

Attributi privati: riponenedo 2 underscore a nome rende l'attributo privato e NON viene ereditata (salvo modi speciali).
Non può essere richiamato o riutilizzato da altre classi

2 NUOVI METODI: Getter e Setter (metodi di istanza)
__get__ e __set__ servono a riportare o stampare un valore
private è un concetto tecnico
il protetto è visibile dai figli, serve a creare la classe base
il padre sono protetti, nei figli li facciamo diventare privati
dal padre al figlio posso aumentare la protezione e non il contrario (regola logica non linguistica)
cosniglio "quando facciamo gli utenti" facciamo un private vuoto e un metodo registrazione e gli assegni le variabili direttamente 
protette


getter e setter (getter nome e setter nome):
su tutti i parametri che devono essere esposti getter e setter
per i parametri che non vanno esposti solo setter (PASS, chiave id, conto bancario etc)

SCOPE DELLE VARIABILI
globale: una variabile globale è  lo vede solo la classe e solo le funziono
si può forzare. es x=10 vale ovunque a meno che non faccio
nella realtà dei fatti globale e locale sono semi inutili.
non locale possiamo forzarlo ma sono elementi passivi

locale

dove lo scrivo determina lo scope (passivo)

nota: non c'entra niente con privato e protetto (un protetto può essere globale)
